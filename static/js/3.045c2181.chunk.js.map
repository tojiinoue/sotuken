{"version":3,"sources":["../../../errors/ccip.ts","../../../utils/ccip.ts","../../../../utils/address/isAddressEqual.ts"],"names":[],"mappings":"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","file":"static/js/3.045c2181.chunk.js","sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupError'\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupResponseMalformedError'\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupSenderMismatchError'\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { call } from '../actions/public/call.js';\nimport {} from '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipFetch({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipFetch({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map"],"sourceRoot":""}